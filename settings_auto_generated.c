/**
 * @file settings_auto_generated.c
 * @author auto-generated
 * @brief Settings_persist模块中自动生成的代码
 * @version 0.1
 * @date 2025-09-23 19:33:15
 *
 * @attention This file is auto-generated by generate_settings_from_ini.py. Do not edit manually!
 * @copyright Copyright (c) 2025
 *
 */
#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include "settings_persist.h"
#define SETTINGS_PERSIST_MODULE_TAG "settings_persist"
#include "settings_persist_log.h"

extern int settings_persist_thread_running;
extern pthread_mutex_t settings_persist_thread_status_mutex;
extern Settings settings_cache;
extern pthread_mutex_t cache_mutex;

int settings_persist_set_Audio_volume(int volume)
{
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("settings_persist_set_Audio_volume");
    if (volume > 100 || volume < 0)
    {
        SETTINGS_PERSIST_LOG_WARN("参数值超出范围: 0~100");
        return -1;
    }

    pthread_mutex_lock(&settings_persist_thread_status_mutex);
    if (settings_persist_thread_running == 0)
    {
        SETTINGS_PERSIST_LOG_WARN("数据更新失败: settings_persist模块未初始化");
        pthread_mutex_unlock(&settings_persist_thread_status_mutex);
        return -2;
    }

    pthread_mutex_lock(&cache_mutex);
    settings_cache.Audio.volume = volume;
    pthread_mutex_unlock(&cache_mutex);
    SETTINGS_PERSIST_LOG_DEBUG("数据更新成功");
    pthread_mutex_unlock(&settings_persist_thread_status_mutex);
    return 0;
}
int settings_persist_set_Audio_mute(bool mute)
{
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("settings_persist_set_Audio_mute");

    pthread_mutex_lock(&settings_persist_thread_status_mutex);
    if (settings_persist_thread_running == 0)
    {
        SETTINGS_PERSIST_LOG_WARN("数据更新失败: settings_persist模块未初始化");
        pthread_mutex_unlock(&settings_persist_thread_status_mutex);
        return -2;
    }

    pthread_mutex_lock(&cache_mutex);
    settings_cache.Audio.mute = mute;
    pthread_mutex_unlock(&cache_mutex);
    SETTINGS_PERSIST_LOG_DEBUG("数据更新成功");
    pthread_mutex_unlock(&settings_persist_thread_status_mutex);
    return 0;
}
int settings_persist_set_Display_brightness(int brightness)
{
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("settings_persist_set_Display_brightness");
    if (brightness > 100 || brightness < 0)
    {
        SETTINGS_PERSIST_LOG_WARN("参数值超出范围: 0~100");
        return -1;
    }

    pthread_mutex_lock(&settings_persist_thread_status_mutex);
    if (settings_persist_thread_running == 0)
    {
        SETTINGS_PERSIST_LOG_WARN("数据更新失败: settings_persist模块未初始化");
        pthread_mutex_unlock(&settings_persist_thread_status_mutex);
        return -2;
    }

    pthread_mutex_lock(&cache_mutex);
    settings_cache.Display.brightness = brightness;
    pthread_mutex_unlock(&cache_mutex);
    SETTINGS_PERSIST_LOG_DEBUG("数据更新成功");
    pthread_mutex_unlock(&settings_persist_thread_status_mutex);
    return 0;
}
int settings_persist_set_Display_screensaver(const char* screensaver)
{
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("settings_persist_set_Display_screensaver");
    if (strlen(screensaver) > 7)
    {
        SETTINGS_PERSIST_LOG_WARN("字符串过长 最大长度为7");
        return -1;
    }

    pthread_mutex_lock(&settings_persist_thread_status_mutex);
    if (settings_persist_thread_running == 0)
    {
        SETTINGS_PERSIST_LOG_WARN("数据更新失败: settings_persist模块未初始化");
        pthread_mutex_unlock(&settings_persist_thread_status_mutex);
        return -2;
    }

    pthread_mutex_lock(&cache_mutex);
    strcpy(settings_cache.Display.screensaver, screensaver);
    pthread_mutex_unlock(&cache_mutex);
    SETTINGS_PERSIST_LOG_DEBUG("数据更新成功");
    pthread_mutex_unlock(&settings_persist_thread_status_mutex);
    return 0;
}

int settings_persist_reset_all_data(void)
{
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("settings_persist_reset_all_data");
    pthread_mutex_lock(&settings_persist_thread_status_mutex);
    if (settings_persist_thread_running == 0)
    {
        SETTINGS_PERSIST_LOG_WARN("数据重置失败: settings_persist模块未初始化");
        pthread_mutex_unlock(&settings_persist_thread_status_mutex);
        return -2;
    }

    pthread_mutex_lock(&cache_mutex);
    settings_restore_defaults(&settings_cache);
    pthread_mutex_unlock(&cache_mutex);
    SETTINGS_PERSIST_LOG_DEBUG("数据重置成功");
    pthread_mutex_unlock(&settings_persist_thread_status_mutex);
    return 0;
}

/**
 * @brief INI文件的解析函数 需搭配inih库使用
 *
 * @param[in, out] user 解析结果
 * @param[in] section 节
 * @param[in] name 相当于key-value对中的key
 * @param[in] value 相当于key-value对中的value
 * @return int
 */
int settings_ini_handler(void* user, const char* section, const char* name, const char* value) {
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("settings_ini_handler");
    Settings* settings = (Settings*)user;
    if (!settings || !section || !name || !value)
    {
        SETTINGS_PERSIST_LOG_ERROR("输入参数中含有NULL");
        return 0;
    }

    if (strcmp(section, "Audio") == 0 && strcmp(name, "volume") == 0) {
        char* endptr;
        long val;
        errno = 0;
        val = strtol(value, &endptr, 10);
        /* 检查转换错误或未转换任何字符 */
        if (errno != 0 || endptr == value) {
            /* 转换失败 使用默认值 */
            settings->Audio.volume = 75;
            SETTINGS_PERSIST_LOG_ERROR("settings.Audio.volume(type:int)转换失败, 已自动恢复默认值: 75");
        } else {
            /* 检查范围 */
            if (val < 0 || val > 100) {
                /* 超出范围 使用默认值 */
                settings->Audio.volume = 75;
                SETTINGS_PERSIST_LOG_ERROR("settings.Audio.volume超出范围[0, 100], 已自动恢复默认值: 75");
            } else {
                settings->Audio.volume = (int)val;
                SETTINGS_PERSIST_LOG_INFO("settings.Audio.volume读取并解析成功: %d", (int)val);
            }
        }
        return 0;
    }

    if (strcmp(section, "Audio") == 0 && strcmp(name, "mute") == 0) {
        if (strcmp(value, "true") == 0) {
            settings->Audio.mute = true;
            SETTINGS_PERSIST_LOG_INFO("settings.Audio.mute读取并解析成功: true");
        } else if (strcmp(value, "false") == 0) {
            settings->Audio.mute = false;
            SETTINGS_PERSIST_LOG_INFO("settings.Audio.mute读取并解析成功: false");
        } else {
            /* 无效的布尔值 使用默认值 */
            settings->Audio.mute = false;
            SETTINGS_PERSIST_LOG_ERROR("settings.Audio.mute(type:bool)转换失败, 已自动恢复默认值: false");
        }
        return 0;
    }

    if (strcmp(section, "Display") == 0 && strcmp(name, "brightness") == 0) {
        char* endptr;
        long val;
        errno = 0;
        val = strtol(value, &endptr, 10);
        /* 检查转换错误或未转换任何字符 */
        if (errno != 0 || endptr == value) {
            /* 转换失败 使用默认值 */
            settings->Display.brightness = 60;
            SETTINGS_PERSIST_LOG_ERROR("settings.Display.brightness(type:int)转换失败, 已自动恢复默认值: 60");
        } else {
            /* 检查范围 */
            if (val < 0 || val > 100) {
                /* 超出范围 使用默认值 */
                settings->Display.brightness = 60;
                SETTINGS_PERSIST_LOG_ERROR("settings.Display.brightness超出范围[0, 100], 已自动恢复默认值: 60");
            } else {
                settings->Display.brightness = (int)val;
                SETTINGS_PERSIST_LOG_INFO("settings.Display.brightness读取并解析成功: %d", (int)val);
            }
        }
        return 0;
    }

    if (strcmp(section, "Display") == 0 && strcmp(name, "screensaver") == 0) {
        strncpy(settings->Display.screensaver, value, sizeof(settings->Display.screensaver)-1);
        settings->Display.screensaver[sizeof(settings->Display.screensaver)-1] = '\0';
        SETTINGS_PERSIST_LOG_INFO("settings.Display.screensaver读取并解析成功: %s", settings->Display.screensaver);
        return 0;
    }

    if (strcmp(section, "Verify") == 0 && strcmp(name, "crc_16_ibm") == 0) {
        char* endptr;
        long val;
        errno = 0;
        val = strtol(value, &endptr, 10);
        /* 检查转换错误或未转换任何字符 */
        if (errno != 0 || endptr == value) {
            /* 转换失败 使用默认值 */
            settings->Verify.crc_16_ibm = 0;
            SETTINGS_PERSIST_LOG_ERROR("settings.Verify.crc_16_ibm(type:int)转换失败, 已自动恢复默认值: 0");
        } else {
            /* 检查范围 */
            if (val < 0 || val > 65535) {
                /* 超出范围 使用默认值 */
                settings->Verify.crc_16_ibm = 0;
                SETTINGS_PERSIST_LOG_ERROR("settings.Verify.crc_16_ibm超出范围[0, 65535], 已自动恢复默认值: 0");
            } else {
                settings->Verify.crc_16_ibm = (int)val;
                SETTINGS_PERSIST_LOG_INFO("settings.Verify.crc_16_ibm读取并解析成功: %d", (int)val);
            }
        }
        return 0;
    }

    /* 未知的 section 或 name - 已忽略 */
    SETTINGS_PERSIST_LOG_WARN("读取到未知数据记录: %s(section)->%s(name)", section, name);
    return 0;
}

/**
 * @brief 将Settings恢复至默认值
 *
 * @param[in, out] settings 目标
 */
void settings_restore_defaults(Settings *settings) {
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("settings_restore_defaults");
    if (!settings)
    {
        SETTINGS_PERSIST_LOG_ERROR("输入参数为NULL");
        return;
    }

    /* 恢复 Audio 至默认值 */
    settings->Audio.volume = 75;
    settings->Audio.mute = false;

    /* 恢复 Display 至默认值 */
    settings->Display.brightness = 60;
    strncpy(settings->Display.screensaver, "enabled", sizeof(settings->Display.screensaver)-1);
    settings->Display.screensaver[sizeof(settings->Display.screensaver)-1] = '\0';

    /* 恢复 Verify 至默认值 */
    settings->Verify.crc_16_ibm = 0;

}

/**
 * @brief 将设置保存到对应文件中(以ini格式)
 *
 * @param[in] filename 保存到的文件路径
 * @param[in] settings 设置值
 * @return 保存结果
 * @retval 0 保存成功
 * @retval -1 保存失败: 输入参数中含有NULL
 * @retval -2 保存失败: 未知原因
 */
int write_settings_to_file(const char* filename, const Settings* settings) {
    SETTINGS_PERSIST_SET_FUNC_LOG_TAG("write_settings_to_file");
    if (!filename || !settings)
    {
        errno = EINVAL;
        SETTINGS_PERSIST_LOG_ERROR("输入参数中含有NULL");
        return -1;
    }

    FILE* file = NULL;
    int retries = 2; /* 最多重试2次(1次正常写入 1次删除重建写入) */

    while (retries-- > 0) {
        /* 尝试正常打开并写入 */
        file = fopen(filename, "w");
        if (file) {
            /* Write Audio settings */
            fprintf(file, "[Audio]\n");
            fprintf(file, "volume=%d\n", settings->Audio.volume);
            fprintf(file, "mute=%s\n", settings->Audio.mute ? "true" : "false");
            /* Write Display settings */
            fprintf(file, "[Display]\n");
            fprintf(file, "brightness=%d\n", settings->Display.brightness);
            fprintf(file, "screensaver=%s\n", settings->Display.screensaver);
            /* Write Verify settings */
            fprintf(file, "[Verify]\n");
            fprintf(file, "crc_16_ibm=%d\n", settings->Verify.crc_16_ibm);
            /* 确保数据刷盘 */
            int fd = fileno(file);
            if (fflush(file) != 0 || fsync(fd) != 0) {
                fclose(file);
                errno = EIO;
                continue; /* 刷盘失败 开始重试 */
            }
            fclose(file);
            SETTINGS_PERSIST_LOG_DEBUG("成功保存");
            return 0; /* 写入成功 */
        }

        SETTINGS_PERSIST_LOG_ERROR("保存失败");
        /* 打开失败 判断是否需要删除重建 */
        int err = errno;
        /* 仅处理"文件存在但无法打开"的情况 */
        if (err != EIO && err != EACCES) {
            /* 其他错误 */
            SETTINGS_PERSIST_LOG_WARN("未知原因, 暂时无法挽救");
            break;
        }
        struct stat st;
        int file_exists = (stat(filename, &st) == 0);
        int is_regular = file_exists ? S_ISREG(st.st_mode) : 0;

        if (file_exists && is_regular) {
            /* 尝试删除异常文件 */
            SETTINGS_PERSIST_LOG_INFO("文件存在但是无法打开, 准备删除重建");
            if (unlink(filename) != 0) {
                /* 删除失败 直接退出 */
                SETTINGS_PERSIST_LOG_ERROR("文件unlink失败, 我也没招了");
                break;
            }
        }
        else {
            SETTINGS_PERSIST_LOG_WARN("文件不存在或不是普通文件 无需删除");
            break;
        }
    }
    /* 所有重试失败 返回错误 */
    SETTINGS_PERSIST_LOG_ERROR("最终还是失败了");
    return -2;
}
